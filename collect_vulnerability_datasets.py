#!/usr/bin/env python3
"""
취약점 데이터셋 수집 및 분석 자동화 스크립트
Vulnerability Dataset Collection and Analysis Automation Script

패치 자동화 연구를 위한 GitHub 취약점 리포지토리 자동 수집 및 분석 도구
"""

import os
import json
import requests
import subprocess
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple
import concurrent.futures
from dataclasses import dataclass
import re

@dataclass
class VulnerabilityRepo:
    """취약점 리포지토리 정보를 담는 데이터 클래스"""
    name: str
    url: str
    description: str
    vulnerability_types: List[str]
    language: str
    priority: int  # 1: 높음, 2: 중간, 3: 낮음
    last_updated: str
    stars: int
    size_kb: int

class VulnerabilityDatasetCollector:
    """취약점 데이터셋 수집기"""
    
    def __init__(self, output_dir: str = "vulnerability_datasets"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # 고품질 취약점 리포지토리 목록
        self.priority_repos = [
            VulnerabilityRepo(
                name="Web-Security-Vulnerabilities",
                url="https://github.com/verylazytech/Web-Security-Vulnerabilities.git",
                description="Python 웹 보안 취약점과 수정 버전",
                vulnerability_types=["SQL Injection", "XSS", "CSRF"],
                language="Python",
                priority=1,
                last_updated="2025-03-05",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="Secure-Code-Snippets-for-Each-Vulnerability", 
                url="https://github.com/ferid333/Secure-Code-Snippets-for-Each-Vulnerability.git",
                description="다양한 취약점에 대한 안전한 코드 예제",
                vulnerability_types=["Multiple"],
                language="Multiple",
                priority=1,
                last_updated="2024-10-02",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="Damn_Vulnerable_C_Program",
                url="https://github.com/hardik05/Damn_Vulnerable_C_Program.git", 
                description="C 언어 일반적인 취약점 예제",
                vulnerability_types=["Buffer Overflow", "Memory Leak"],
                language="C",
                priority=1,
                last_updated="2024-10-19",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="SecurityEval",
                url="https://github.com/s2e-lab/SecurityEval.git",
                description="ML 기반 코드 생성 기술 평가용 취약점 예제", 
                vulnerability_types=["Code Generation Vulnerabilities"],
                language="Multiple",
                priority=2,
                last_updated="2023-11-04",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="SWCVulnerableCode",
                url="https://github.com/SaurabhSinghDev/SWCVulnerableCode.git",
                description="SWC-100~120 Solidity 취약점 예제",
                vulnerability_types=["Smart Contract Vulnerabilities"],
                language="Solidity", 
                priority=2,
                last_updated="2023-12-17",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="juice-shop",
                url="https://github.com/juice-shop/juice-shop.git",
                description="OWASP Juice Shop - 현대적이고 정교한 취약한 웹 애플리케이션",
                vulnerability_types=["OWASP Top 10"],
                language="JavaScript",
                priority=3,
                last_updated="2025-07-09", 
                stars=0,
                size_kb=0
            )
        ]
    
    def clone_repository(self, repo: VulnerabilityRepo) -> bool:
        """리포지토리 클론"""
        try:
            repo_path = self.output_dir / repo.name
            if repo_path.exists():
                print(f"✓ {repo.name} 이미 존재함")
                return True
                
            print(f"📥 {repo.name} 클론 중...")
            result = subprocess.run(
                ["git", "clone", repo.url, str(repo_path)],
                capture_output=True,
                text=True,
                timeout=300  # 5분 타임아웃
            )
            
            if result.returncode == 0:
                print(f"✅ {repo.name} 클론 완료")
                return True
            else:
                print(f"❌ {repo.name} 클론 실패: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print(f"⏰ {repo.name} 클론 타임아웃")
            return False
        except Exception as e:
            print(f"❌ {repo.name} 클론 중 오류: {e}")
            return False
    
    def analyze_repository(self, repo: VulnerabilityRepo) -> Dict:
        """리포지토리 분석"""
        repo_path = self.output_dir / repo.name
        if not repo_path.exists():
            return {"error": "Repository not found"}
        
        analysis = {
            "name": repo.name,
            "path": str(repo_path),
            "vulnerability_types": repo.vulnerability_types,
            "language": repo.language,
            "priority": repo.priority,
            "files": [],
            "stats": {}
        }
        
        # 파일 분석
        vulnerability_files = []
        for ext in [".py", ".js", ".java", ".c", ".cpp", ".cs", ".php", ".sol"]:
            pattern = f"**/*{ext}"
            files = list(repo_path.glob(pattern))
            vulnerability_files.extend(files)
        
        # 취약점 관련 키워드 탐지
        vulnerability_keywords = [
            "sql injection", "xss", "csrf", "buffer overflow", 
            "reentrancy", "vulnerable", "exploit", "attack",
            "insecure", "unsafe", "backdoor", "malicious"
        ]
        
        analyzed_files = []
        for file_path in vulnerability_files[:50]:  # 최대 50개 파일만 분석
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()
                    
                detected_vulnerabilities = []
                for keyword in vulnerability_keywords:
                    if keyword in content:
                        detected_vulnerabilities.append(keyword)
                
                if detected_vulnerabilities:
                    analyzed_files.append({
                        "path": str(file_path.relative_to(repo_path)),
                        "size": file_path.stat().st_size,
                        "vulnerabilities": detected_vulnerabilities,
                        "language": file_path.suffix[1:] if file_path.suffix else "unknown"
                    })
                    
            except Exception as e:
                continue
        
        analysis["files"] = analyzed_files
        analysis["stats"] = {
            "total_files": len(vulnerability_files),
            "analyzed_files": len(analyzed_files),
            "total_size_bytes": sum(f.stat().st_size for f in vulnerability_files if f.exists()),
            "vulnerability_count": len(analyzed_files)
        }
        
        return analysis
    
    def extract_vulnerable_secure_pairs(self, repo_path: Path) -> List[Tuple[str, str]]:
        """취약한 코드와 보안 코드 쌍 추출"""
        pairs = []
        
        # 일반적인 패턴으로 쌍 찾기
        patterns = [
            ("vulnerable", "secure"),
            ("vuln", "safe"), 
            ("bad", "good"),
            ("insecure", "secure"),
            ("before", "after")
        ]
        
        for vuln_pattern, secure_pattern in patterns:
            vuln_files = list(repo_path.glob(f"**/*{vuln_pattern}*"))
            
            for vuln_file in vuln_files:
                # 대응하는 보안 파일 찾기
                secure_file_name = vuln_file.name.replace(vuln_pattern, secure_pattern)
                secure_file = vuln_file.parent / secure_file_name
                
                if secure_file.exists():
                    pairs.append((str(vuln_file), str(secure_file)))
        
        return pairs
    
    def generate_dataset_summary(self, analyses: List[Dict]) -> Dict:
        """데이터셋 요약 생성"""
        summary = {
            "collection_date": datetime.now().isoformat(),
            "total_repositories": len(analyses),
            "languages": {},
            "vulnerability_types": {},
            "priority_distribution": {"1": 0, "2": 0, "3": 0},
            "total_files": 0,
            "total_size_mb": 0
        }
        
        for analysis in analyses:
            if "error" in analysis:
                continue
                
            # 언어별 통계
            lang = analysis["language"]
            if lang not in summary["languages"]:
                summary["languages"][lang] = 0
            summary["languages"][lang] += 1
            
            # 취약점 유형별 통계
            for vuln_type in analysis["vulnerability_types"]:
                if vuln_type not in summary["vulnerability_types"]:
                    summary["vulnerability_types"][vuln_type] = 0
                summary["vulnerability_types"][vuln_type] += 1
            
            # 우선순위별 통계
            priority = str(analysis["priority"])
            summary["priority_distribution"][priority] += 1
            
            # 파일 통계
            if "stats" in analysis:
                summary["total_files"] += analysis["stats"].get("total_files", 0)
                summary["total_size_mb"] += analysis["stats"].get("total_size_bytes", 0) / (1024 * 1024)
        
        return summary
    
    def export_to_csv(self, analyses: List[Dict], filename: str = "vulnerability_dataset.csv"):
        """CSV로 내보내기"""
        csv_path = self.output_dir / filename
        
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = [
                "repository", "language", "priority", "vulnerability_types", 
                "file_path", "file_size", "detected_vulnerabilities"
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for analysis in analyses:
                if "error" in analysis:
                    continue
                    
                for file_info in analysis["files"]:
                    writer.writerow({
                        "repository": analysis["name"],
                        "language": analysis["language"], 
                        "priority": analysis["priority"],
                        "vulnerability_types": "|".join(analysis["vulnerability_types"]),
                        "file_path": file_info["path"],
                        "file_size": file_info["size"],
                        "detected_vulnerabilities": "|".join(file_info["vulnerabilities"])
                    })
        
        print(f"📊 CSV 파일 생성: {csv_path}")
    
    def run_collection(self):
        """전체 수집 프로세스 실행"""
        print("🚀 취약점 데이터셋 수집 시작...")
        
        # 1단계: 고우선순위 리포지토리 클론
        print("\n📦 1단계: 리포지토리 클론")
        successful_repos = []
        
        for repo in self.priority_repos:
            if self.clone_repository(repo):
                successful_repos.append(repo)
        
        print(f"\n✅ {len(successful_repos)}/{len(self.priority_repos)} 리포지토리 클론 성공")
        
        # 2단계: 리포지토리 분석
        print("\n🔍 2단계: 리포지토리 분석")
        analyses = []
        
        for repo in successful_repos:
            print(f"🔎 {repo.name} 분석 중...")
            analysis = self.analyze_repository(repo)
            analyses.append(analysis)
            
            if "error" not in analysis:
                print(f"  📁 파일 {analysis['stats']['total_files']}개 중 {analysis['stats']['vulnerability_count']}개에서 취약점 키워드 발견")
        
        # 3단계: 결과 저장
        print("\n💾 3단계: 결과 저장")
        
        # JSON 저장
        results_path = self.output_dir / "analysis_results.json"
        with open(results_path, 'w', encoding='utf-8') as f:
            json.dump(analyses, f, indent=2, ensure_ascii=False)
        print(f"📄 분석 결과 저장: {results_path}")
        
        # CSV 저장
        self.export_to_csv(analyses)
        
        # 요약 저장
        summary = self.generate_dataset_summary(analyses)
        summary_path = self.output_dir / "dataset_summary.json"
        with open(summary_path, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        print(f"📊 데이터셋 요약 저장: {summary_path}")
        
        # 4단계: 취약점-보안 코드 쌍 추출
        print("\n🔗 4단계: 취약점-보안 코드 쌍 추출")
        pairs_found = 0
        
        for repo in successful_repos:
            repo_path = self.output_dir / repo.name
            pairs = self.extract_vulnerable_secure_pairs(repo_path)
            
            if pairs:
                pairs_file = self.output_dir / f"{repo.name}_pairs.json"
                with open(pairs_file, 'w', encoding='utf-8') as f:
                    json.dump(pairs, f, indent=2)
                print(f"  🔗 {repo.name}: {len(pairs)}개 쌍 발견")
                pairs_found += len(pairs)
        
        print(f"\n🎉 수집 완료!")
        print(f"📈 총 {len(successful_repos)}개 리포지토리, {pairs_found}개 취약점-보안 코드 쌍 수집")
        print(f"📂 결과 디렉토리: {self.output_dir}")

class VulnerabilityPatternAnalyzer:
    """취약점 패턴 분석기"""
    
    def __init__(self, dataset_path: str):
        self.dataset_path = Path(dataset_path)
    
    def analyze_sql_injection_patterns(self) -> Dict:
        """SQL Injection 패턴 분석"""
        patterns = {
            "vulnerable_patterns": [
                r"execute\s*\(\s*[\"'].*%.*[\"']\s*%",  # Python string formatting
                r"query\s*=\s*[\"'].*\+.*[\"']",        # String concatenation
                r"SELECT.*FROM.*WHERE.*=.*\$_",         # PHP direct variable use
                r"cursor\.execute\s*\(\s*[\"'][^\"']*\+", # Python cursor execute with concat
            ],
            "secure_patterns": [
                r"execute\s*\(\s*[\"'][^%]*[\"']\s*,\s*\(",  # Parameterized queries
                r"prepare\s*\(\s*[\"'][^+]*[\"']\s*\)",      # Prepared statements
                r"query\s*=\s*[\"'][^+]*\?\s*[\"']",         # Question mark placeholders
            ]
        }
        return patterns
    
    def analyze_xss_patterns(self) -> Dict:
        """XSS 패턴 분석"""
        patterns = {
            "vulnerable_patterns": [
                r"innerHTML\s*=\s*.*\+",                    # Direct innerHTML assignment
                r"document\.write\s*\(\s*.*\+",             # document.write with concatenation
                r"echo\s+\$_[GET|POST]",                    # PHP direct echo
                r"\.html\s*\(\s*.*\+",                      # jQuery html() with concat
            ],
            "secure_patterns": [
                r"textContent\s*=",                         # textContent instead of innerHTML
                r"escape\s*\(",                            # Escape functions
                r"htmlspecialchars\s*\(",                   # PHP htmlspecialchars
                r"\.text\s*\(",                            # jQuery text() method
            ]
        }
        return patterns
    
    def scan_code_patterns(self, file_path: Path) -> Dict:
        """코드 파일에서 패턴 스캔"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            results = {
                "file": str(file_path),
                "sql_injection": {"vulnerable": [], "secure": []},
                "xss": {"vulnerable": [], "secure": []}
            }
            
            # SQL Injection 패턴 검사
            sql_patterns = self.analyze_sql_injection_patterns()
            for pattern in sql_patterns["vulnerable_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["sql_injection"]["vulnerable"].extend(matches)
            
            for pattern in sql_patterns["secure_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["sql_injection"]["secure"].extend(matches)
            
            # XSS 패턴 검사
            xss_patterns = self.analyze_xss_patterns()
            for pattern in xss_patterns["vulnerable_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["xss"]["vulnerable"].extend(matches)
            
            for pattern in xss_patterns["secure_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["xss"]["secure"].extend(matches)
            
            return results
            
        except Exception as e:
            return {"file": str(file_path), "error": str(e)}

def main():
    """메인 실행 함수"""
    print("=" * 60)
    print("🛡️  취약점 데이터셋 수집 및 분석 도구")
    print("   Vulnerability Dataset Collection & Analysis Tool")
    print("=" * 60)
    
    # 데이터셋 수집기 실행
    collector = VulnerabilityDatasetCollector()
    collector.run_collection()
    
    # 패턴 분석기 실행
    print("\n🔍 패턴 분석 시작...")
    analyzer = VulnerabilityPatternAnalyzer("vulnerability_datasets")
    
    # 수집된 파일들에 대해 패턴 분석 수행
    pattern_results = []
    dataset_path = Path("vulnerability_datasets")
    
    for repo_dir in dataset_path.iterdir():
        if repo_dir.is_dir() and not repo_dir.name.startswith('.'):
            print(f"🔎 {repo_dir.name} 패턴 분석 중...")
            
            for code_file in repo_dir.glob("**/*"):
                if code_file.suffix in ['.py', '.js', '.php', '.java', '.c', '.cpp']:
                    result = analyzer.scan_code_patterns(code_file)
                    if "error" not in result:
                        # 취약점이나 보안 패턴이 발견된 경우만 저장
                        has_patterns = (
                            result["sql_injection"]["vulnerable"] or 
                            result["sql_injection"]["secure"] or
                            result["xss"]["vulnerable"] or 
                            result["xss"]["secure"]
                        )
                        if has_patterns:
                            pattern_results.append(result)
    
    # 패턴 분석 결과 저장
    if pattern_results:
        pattern_output = dataset_path / "pattern_analysis.json"
        with open(pattern_output, 'w', encoding='utf-8') as f:
            json.dump(pattern_results, f, indent=2, ensure_ascii=False)
        print(f"📊 패턴 분석 결과 저장: {pattern_output}")
        print(f"🔍 {len(pattern_results)}개 파일에서 보안 패턴 발견")
    
    print("\n✨ 모든 작업 완료!")
    print(f"📂 결과 확인: vulnerability_datasets/")

if __name__ == "__main__":
    main()
