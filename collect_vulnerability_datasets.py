#!/usr/bin/env python3
"""
ì·¨ì•½ì  ë°ì´í„°ì…‹ ìˆ˜ì§‘ ë° ë¶„ì„ ìë™í™” ìŠ¤í¬ë¦½íŠ¸
Vulnerability Dataset Collection and Analysis Automation Script

íŒ¨ì¹˜ ìë™í™” ì—°êµ¬ë¥¼ ìœ„í•œ GitHub ì·¨ì•½ì  ë¦¬í¬ì§€í† ë¦¬ ìë™ ìˆ˜ì§‘ ë° ë¶„ì„ ë„êµ¬
"""

import os
import json
import requests
import subprocess
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple
import concurrent.futures
from dataclasses import dataclass
import re

@dataclass
class VulnerabilityRepo:
    """ì·¨ì•½ì  ë¦¬í¬ì§€í† ë¦¬ ì •ë³´ë¥¼ ë‹´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    name: str
    url: str
    description: str
    vulnerability_types: List[str]
    language: str
    priority: int  # 1: ë†’ìŒ, 2: ì¤‘ê°„, 3: ë‚®ìŒ
    last_updated: str
    stars: int
    size_kb: int

class VulnerabilityDatasetCollector:
    """ì·¨ì•½ì  ë°ì´í„°ì…‹ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, output_dir: str = "vulnerability_datasets"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # ê³ í’ˆì§ˆ ì·¨ì•½ì  ë¦¬í¬ì§€í† ë¦¬ ëª©ë¡
        self.priority_repos = [
            VulnerabilityRepo(
                name="Web-Security-Vulnerabilities",
                url="https://github.com/verylazytech/Web-Security-Vulnerabilities.git",
                description="Python ì›¹ ë³´ì•ˆ ì·¨ì•½ì ê³¼ ìˆ˜ì • ë²„ì „",
                vulnerability_types=["SQL Injection", "XSS", "CSRF"],
                language="Python",
                priority=1,
                last_updated="2025-03-05",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="Secure-Code-Snippets-for-Each-Vulnerability", 
                url="https://github.com/ferid333/Secure-Code-Snippets-for-Each-Vulnerability.git",
                description="ë‹¤ì–‘í•œ ì·¨ì•½ì ì— ëŒ€í•œ ì•ˆì „í•œ ì½”ë“œ ì˜ˆì œ",
                vulnerability_types=["Multiple"],
                language="Multiple",
                priority=1,
                last_updated="2024-10-02",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="Damn_Vulnerable_C_Program",
                url="https://github.com/hardik05/Damn_Vulnerable_C_Program.git", 
                description="C ì–¸ì–´ ì¼ë°˜ì ì¸ ì·¨ì•½ì  ì˜ˆì œ",
                vulnerability_types=["Buffer Overflow", "Memory Leak"],
                language="C",
                priority=1,
                last_updated="2024-10-19",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="SecurityEval",
                url="https://github.com/s2e-lab/SecurityEval.git",
                description="ML ê¸°ë°˜ ì½”ë“œ ìƒì„± ê¸°ìˆ  í‰ê°€ìš© ì·¨ì•½ì  ì˜ˆì œ", 
                vulnerability_types=["Code Generation Vulnerabilities"],
                language="Multiple",
                priority=2,
                last_updated="2023-11-04",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="SWCVulnerableCode",
                url="https://github.com/SaurabhSinghDev/SWCVulnerableCode.git",
                description="SWC-100~120 Solidity ì·¨ì•½ì  ì˜ˆì œ",
                vulnerability_types=["Smart Contract Vulnerabilities"],
                language="Solidity", 
                priority=2,
                last_updated="2023-12-17",
                stars=0,
                size_kb=0
            ),
            VulnerabilityRepo(
                name="juice-shop",
                url="https://github.com/juice-shop/juice-shop.git",
                description="OWASP Juice Shop - í˜„ëŒ€ì ì´ê³  ì •êµí•œ ì·¨ì•½í•œ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜",
                vulnerability_types=["OWASP Top 10"],
                language="JavaScript",
                priority=3,
                last_updated="2025-07-09", 
                stars=0,
                size_kb=0
            )
        ]
    
    def clone_repository(self, repo: VulnerabilityRepo) -> bool:
        """ë¦¬í¬ì§€í† ë¦¬ í´ë¡ """
        try:
            repo_path = self.output_dir / repo.name
            if repo_path.exists():
                print(f"âœ“ {repo.name} ì´ë¯¸ ì¡´ì¬í•¨")
                return True
                
            print(f"ğŸ“¥ {repo.name} í´ë¡  ì¤‘...")
            result = subprocess.run(
                ["git", "clone", repo.url, str(repo_path)],
                capture_output=True,
                text=True,
                timeout=300  # 5ë¶„ íƒ€ì„ì•„ì›ƒ
            )
            
            if result.returncode == 0:
                print(f"âœ… {repo.name} í´ë¡  ì™„ë£Œ")
                return True
            else:
                print(f"âŒ {repo.name} í´ë¡  ì‹¤íŒ¨: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print(f"â° {repo.name} í´ë¡  íƒ€ì„ì•„ì›ƒ")
            return False
        except Exception as e:
            print(f"âŒ {repo.name} í´ë¡  ì¤‘ ì˜¤ë¥˜: {e}")
            return False
    
    def analyze_repository(self, repo: VulnerabilityRepo) -> Dict:
        """ë¦¬í¬ì§€í† ë¦¬ ë¶„ì„"""
        repo_path = self.output_dir / repo.name
        if not repo_path.exists():
            return {"error": "Repository not found"}
        
        analysis = {
            "name": repo.name,
            "path": str(repo_path),
            "vulnerability_types": repo.vulnerability_types,
            "language": repo.language,
            "priority": repo.priority,
            "files": [],
            "stats": {}
        }
        
        # íŒŒì¼ ë¶„ì„
        vulnerability_files = []
        for ext in [".py", ".js", ".java", ".c", ".cpp", ".cs", ".php", ".sol"]:
            pattern = f"**/*{ext}"
            files = list(repo_path.glob(pattern))
            vulnerability_files.extend(files)
        
        # ì·¨ì•½ì  ê´€ë ¨ í‚¤ì›Œë“œ íƒì§€
        vulnerability_keywords = [
            "sql injection", "xss", "csrf", "buffer overflow", 
            "reentrancy", "vulnerable", "exploit", "attack",
            "insecure", "unsafe", "backdoor", "malicious"
        ]
        
        analyzed_files = []
        for file_path in vulnerability_files[:50]:  # ìµœëŒ€ 50ê°œ íŒŒì¼ë§Œ ë¶„ì„
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()
                    
                detected_vulnerabilities = []
                for keyword in vulnerability_keywords:
                    if keyword in content:
                        detected_vulnerabilities.append(keyword)
                
                if detected_vulnerabilities:
                    analyzed_files.append({
                        "path": str(file_path.relative_to(repo_path)),
                        "size": file_path.stat().st_size,
                        "vulnerabilities": detected_vulnerabilities,
                        "language": file_path.suffix[1:] if file_path.suffix else "unknown"
                    })
                    
            except Exception as e:
                continue
        
        analysis["files"] = analyzed_files
        analysis["stats"] = {
            "total_files": len(vulnerability_files),
            "analyzed_files": len(analyzed_files),
            "total_size_bytes": sum(f.stat().st_size for f in vulnerability_files if f.exists()),
            "vulnerability_count": len(analyzed_files)
        }
        
        return analysis
    
    def extract_vulnerable_secure_pairs(self, repo_path: Path) -> List[Tuple[str, str]]:
        """ì·¨ì•½í•œ ì½”ë“œì™€ ë³´ì•ˆ ì½”ë“œ ìŒ ì¶”ì¶œ"""
        pairs = []
        
        # ì¼ë°˜ì ì¸ íŒ¨í„´ìœ¼ë¡œ ìŒ ì°¾ê¸°
        patterns = [
            ("vulnerable", "secure"),
            ("vuln", "safe"), 
            ("bad", "good"),
            ("insecure", "secure"),
            ("before", "after")
        ]
        
        for vuln_pattern, secure_pattern in patterns:
            vuln_files = list(repo_path.glob(f"**/*{vuln_pattern}*"))
            
            for vuln_file in vuln_files:
                # ëŒ€ì‘í•˜ëŠ” ë³´ì•ˆ íŒŒì¼ ì°¾ê¸°
                secure_file_name = vuln_file.name.replace(vuln_pattern, secure_pattern)
                secure_file = vuln_file.parent / secure_file_name
                
                if secure_file.exists():
                    pairs.append((str(vuln_file), str(secure_file)))
        
        return pairs
    
    def generate_dataset_summary(self, analyses: List[Dict]) -> Dict:
        """ë°ì´í„°ì…‹ ìš”ì•½ ìƒì„±"""
        summary = {
            "collection_date": datetime.now().isoformat(),
            "total_repositories": len(analyses),
            "languages": {},
            "vulnerability_types": {},
            "priority_distribution": {"1": 0, "2": 0, "3": 0},
            "total_files": 0,
            "total_size_mb": 0
        }
        
        for analysis in analyses:
            if "error" in analysis:
                continue
                
            # ì–¸ì–´ë³„ í†µê³„
            lang = analysis["language"]
            if lang not in summary["languages"]:
                summary["languages"][lang] = 0
            summary["languages"][lang] += 1
            
            # ì·¨ì•½ì  ìœ í˜•ë³„ í†µê³„
            for vuln_type in analysis["vulnerability_types"]:
                if vuln_type not in summary["vulnerability_types"]:
                    summary["vulnerability_types"][vuln_type] = 0
                summary["vulnerability_types"][vuln_type] += 1
            
            # ìš°ì„ ìˆœìœ„ë³„ í†µê³„
            priority = str(analysis["priority"])
            summary["priority_distribution"][priority] += 1
            
            # íŒŒì¼ í†µê³„
            if "stats" in analysis:
                summary["total_files"] += analysis["stats"].get("total_files", 0)
                summary["total_size_mb"] += analysis["stats"].get("total_size_bytes", 0) / (1024 * 1024)
        
        return summary
    
    def export_to_csv(self, analyses: List[Dict], filename: str = "vulnerability_dataset.csv"):
        """CSVë¡œ ë‚´ë³´ë‚´ê¸°"""
        csv_path = self.output_dir / filename
        
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = [
                "repository", "language", "priority", "vulnerability_types", 
                "file_path", "file_size", "detected_vulnerabilities"
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for analysis in analyses:
                if "error" in analysis:
                    continue
                    
                for file_info in analysis["files"]:
                    writer.writerow({
                        "repository": analysis["name"],
                        "language": analysis["language"], 
                        "priority": analysis["priority"],
                        "vulnerability_types": "|".join(analysis["vulnerability_types"]),
                        "file_path": file_info["path"],
                        "file_size": file_info["size"],
                        "detected_vulnerabilities": "|".join(file_info["vulnerabilities"])
                    })
        
        print(f"ğŸ“Š CSV íŒŒì¼ ìƒì„±: {csv_path}")
    
    def run_collection(self):
        """ì „ì²´ ìˆ˜ì§‘ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰"""
        print("ğŸš€ ì·¨ì•½ì  ë°ì´í„°ì…‹ ìˆ˜ì§‘ ì‹œì‘...")
        
        # 1ë‹¨ê³„: ê³ ìš°ì„ ìˆœìœ„ ë¦¬í¬ì§€í† ë¦¬ í´ë¡ 
        print("\nğŸ“¦ 1ë‹¨ê³„: ë¦¬í¬ì§€í† ë¦¬ í´ë¡ ")
        successful_repos = []
        
        for repo in self.priority_repos:
            if self.clone_repository(repo):
                successful_repos.append(repo)
        
        print(f"\nâœ… {len(successful_repos)}/{len(self.priority_repos)} ë¦¬í¬ì§€í† ë¦¬ í´ë¡  ì„±ê³µ")
        
        # 2ë‹¨ê³„: ë¦¬í¬ì§€í† ë¦¬ ë¶„ì„
        print("\nğŸ” 2ë‹¨ê³„: ë¦¬í¬ì§€í† ë¦¬ ë¶„ì„")
        analyses = []
        
        for repo in successful_repos:
            print(f"ğŸ” {repo.name} ë¶„ì„ ì¤‘...")
            analysis = self.analyze_repository(repo)
            analyses.append(analysis)
            
            if "error" not in analysis:
                print(f"  ğŸ“ íŒŒì¼ {analysis['stats']['total_files']}ê°œ ì¤‘ {analysis['stats']['vulnerability_count']}ê°œì—ì„œ ì·¨ì•½ì  í‚¤ì›Œë“œ ë°œê²¬")
        
        # 3ë‹¨ê³„: ê²°ê³¼ ì €ì¥
        print("\nğŸ’¾ 3ë‹¨ê³„: ê²°ê³¼ ì €ì¥")
        
        # JSON ì €ì¥
        results_path = self.output_dir / "analysis_results.json"
        with open(results_path, 'w', encoding='utf-8') as f:
            json.dump(analyses, f, indent=2, ensure_ascii=False)
        print(f"ğŸ“„ ë¶„ì„ ê²°ê³¼ ì €ì¥: {results_path}")
        
        # CSV ì €ì¥
        self.export_to_csv(analyses)
        
        # ìš”ì•½ ì €ì¥
        summary = self.generate_dataset_summary(analyses)
        summary_path = self.output_dir / "dataset_summary.json"
        with open(summary_path, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        print(f"ğŸ“Š ë°ì´í„°ì…‹ ìš”ì•½ ì €ì¥: {summary_path}")
        
        # 4ë‹¨ê³„: ì·¨ì•½ì -ë³´ì•ˆ ì½”ë“œ ìŒ ì¶”ì¶œ
        print("\nğŸ”— 4ë‹¨ê³„: ì·¨ì•½ì -ë³´ì•ˆ ì½”ë“œ ìŒ ì¶”ì¶œ")
        pairs_found = 0
        
        for repo in successful_repos:
            repo_path = self.output_dir / repo.name
            pairs = self.extract_vulnerable_secure_pairs(repo_path)
            
            if pairs:
                pairs_file = self.output_dir / f"{repo.name}_pairs.json"
                with open(pairs_file, 'w', encoding='utf-8') as f:
                    json.dump(pairs, f, indent=2)
                print(f"  ğŸ”— {repo.name}: {len(pairs)}ê°œ ìŒ ë°œê²¬")
                pairs_found += len(pairs)
        
        print(f"\nğŸ‰ ìˆ˜ì§‘ ì™„ë£Œ!")
        print(f"ğŸ“ˆ ì´ {len(successful_repos)}ê°œ ë¦¬í¬ì§€í† ë¦¬, {pairs_found}ê°œ ì·¨ì•½ì -ë³´ì•ˆ ì½”ë“œ ìŒ ìˆ˜ì§‘")
        print(f"ğŸ“‚ ê²°ê³¼ ë””ë ‰í† ë¦¬: {self.output_dir}")

class VulnerabilityPatternAnalyzer:
    """ì·¨ì•½ì  íŒ¨í„´ ë¶„ì„ê¸°"""
    
    def __init__(self, dataset_path: str):
        self.dataset_path = Path(dataset_path)
    
    def analyze_sql_injection_patterns(self) -> Dict:
        """SQL Injection íŒ¨í„´ ë¶„ì„"""
        patterns = {
            "vulnerable_patterns": [
                r"execute\s*\(\s*[\"'].*%.*[\"']\s*%",  # Python string formatting
                r"query\s*=\s*[\"'].*\+.*[\"']",        # String concatenation
                r"SELECT.*FROM.*WHERE.*=.*\$_",         # PHP direct variable use
                r"cursor\.execute\s*\(\s*[\"'][^\"']*\+", # Python cursor execute with concat
            ],
            "secure_patterns": [
                r"execute\s*\(\s*[\"'][^%]*[\"']\s*,\s*\(",  # Parameterized queries
                r"prepare\s*\(\s*[\"'][^+]*[\"']\s*\)",      # Prepared statements
                r"query\s*=\s*[\"'][^+]*\?\s*[\"']",         # Question mark placeholders
            ]
        }
        return patterns
    
    def analyze_xss_patterns(self) -> Dict:
        """XSS íŒ¨í„´ ë¶„ì„"""
        patterns = {
            "vulnerable_patterns": [
                r"innerHTML\s*=\s*.*\+",                    # Direct innerHTML assignment
                r"document\.write\s*\(\s*.*\+",             # document.write with concatenation
                r"echo\s+\$_[GET|POST]",                    # PHP direct echo
                r"\.html\s*\(\s*.*\+",                      # jQuery html() with concat
            ],
            "secure_patterns": [
                r"textContent\s*=",                         # textContent instead of innerHTML
                r"escape\s*\(",                            # Escape functions
                r"htmlspecialchars\s*\(",                   # PHP htmlspecialchars
                r"\.text\s*\(",                            # jQuery text() method
            ]
        }
        return patterns
    
    def scan_code_patterns(self, file_path: Path) -> Dict:
        """ì½”ë“œ íŒŒì¼ì—ì„œ íŒ¨í„´ ìŠ¤ìº”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            results = {
                "file": str(file_path),
                "sql_injection": {"vulnerable": [], "secure": []},
                "xss": {"vulnerable": [], "secure": []}
            }
            
            # SQL Injection íŒ¨í„´ ê²€ì‚¬
            sql_patterns = self.analyze_sql_injection_patterns()
            for pattern in sql_patterns["vulnerable_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["sql_injection"]["vulnerable"].extend(matches)
            
            for pattern in sql_patterns["secure_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["sql_injection"]["secure"].extend(matches)
            
            # XSS íŒ¨í„´ ê²€ì‚¬
            xss_patterns = self.analyze_xss_patterns()
            for pattern in xss_patterns["vulnerable_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["xss"]["vulnerable"].extend(matches)
            
            for pattern in xss_patterns["secure_patterns"]:
                matches = re.findall(pattern, content, re.IGNORECASE)
                results["xss"]["secure"].extend(matches)
            
            return results
            
        except Exception as e:
            return {"file": str(file_path), "error": str(e)}

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("=" * 60)
    print("ğŸ›¡ï¸  ì·¨ì•½ì  ë°ì´í„°ì…‹ ìˆ˜ì§‘ ë° ë¶„ì„ ë„êµ¬")
    print("   Vulnerability Dataset Collection & Analysis Tool")
    print("=" * 60)
    
    # ë°ì´í„°ì…‹ ìˆ˜ì§‘ê¸° ì‹¤í–‰
    collector = VulnerabilityDatasetCollector()
    collector.run_collection()
    
    # íŒ¨í„´ ë¶„ì„ê¸° ì‹¤í–‰
    print("\nğŸ” íŒ¨í„´ ë¶„ì„ ì‹œì‘...")
    analyzer = VulnerabilityPatternAnalyzer("vulnerability_datasets")
    
    # ìˆ˜ì§‘ëœ íŒŒì¼ë“¤ì— ëŒ€í•´ íŒ¨í„´ ë¶„ì„ ìˆ˜í–‰
    pattern_results = []
    dataset_path = Path("vulnerability_datasets")
    
    for repo_dir in dataset_path.iterdir():
        if repo_dir.is_dir() and not repo_dir.name.startswith('.'):
            print(f"ğŸ” {repo_dir.name} íŒ¨í„´ ë¶„ì„ ì¤‘...")
            
            for code_file in repo_dir.glob("**/*"):
                if code_file.suffix in ['.py', '.js', '.php', '.java', '.c', '.cpp']:
                    result = analyzer.scan_code_patterns(code_file)
                    if "error" not in result:
                        # ì·¨ì•½ì ì´ë‚˜ ë³´ì•ˆ íŒ¨í„´ì´ ë°œê²¬ëœ ê²½ìš°ë§Œ ì €ì¥
                        has_patterns = (
                            result["sql_injection"]["vulnerable"] or 
                            result["sql_injection"]["secure"] or
                            result["xss"]["vulnerable"] or 
                            result["xss"]["secure"]
                        )
                        if has_patterns:
                            pattern_results.append(result)
    
    # íŒ¨í„´ ë¶„ì„ ê²°ê³¼ ì €ì¥
    if pattern_results:
        pattern_output = dataset_path / "pattern_analysis.json"
        with open(pattern_output, 'w', encoding='utf-8') as f:
            json.dump(pattern_results, f, indent=2, ensure_ascii=False)
        print(f"ğŸ“Š íŒ¨í„´ ë¶„ì„ ê²°ê³¼ ì €ì¥: {pattern_output}")
        print(f"ğŸ” {len(pattern_results)}ê°œ íŒŒì¼ì—ì„œ ë³´ì•ˆ íŒ¨í„´ ë°œê²¬")
    
    print("\nâœ¨ ëª¨ë“  ì‘ì—… ì™„ë£Œ!")
    print(f"ğŸ“‚ ê²°ê³¼ í™•ì¸: vulnerability_datasets/")

if __name__ == "__main__":
    main()
